import{_ as e,c as t,o as r,aF as i}from"./chunks/framework.CvyoTX4A.js";const o="/assets/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210805144708.D1KhSqdU.png",p="/assets/image-20210805145620892.BMjHwdQV.png",s="/assets/image-20210805152243259.Bk2vcR6R.png",h="/assets/image-20210805161141288.D3kZmObR.png",l="/assets/image-20210805172109798.CFjdbSOa.png",n="/assets/image-20210805172818490.BYpzB0Ak.png",d="/assets/image-20210806135306874.jrEFb_h1.png",_="/assets/image-20210806135908287.DuH4cQpo.png",c="/assets/image-20210806140028854.DlcFZwrf.png",m="/assets/image-20210806141113335.V1fDw_-d.png",u="/assets/image-20210806141218613.BrXUWX1I.png",b="/assets/image-20210806141314027.CynTl4iJ.png",q="/assets/image-20210806141358316.9K-W_nIf.png",E="/assets/image-20210806141545549.Dhww_EeU.png",R=JSON.parse('{"title":"图解密码技术第三版-结城浩","description":"","frontmatter":{},"headers":[],"relativePath":"mds/6-📝读书笔记/1-程序人生/1-密码学读书笔记/1-密码读书.md","filePath":"mds/6-📝读书笔记/1-程序人生/1-密码学读书笔记/1-密码读书.md"}'),g={name:"mds/6-📝读书笔记/1-程序人生/1-密码学读书笔记/1-密码读书.md"};function S(f,a,D,x,k,P){return r(),t("div",null,a[0]||(a[0]=[i('<p>[TOC]</p><h1 id="图解密码技术第三版-结城浩" tabindex="-1">图解密码技术第三版-结城浩 <a class="header-anchor" href="#图解密码技术第三版-结城浩" aria-label="Permalink to &quot;图解密码技术第三版-结城浩&quot;">​</a></h1><h2 id="_0-概述" tabindex="-1">0 概述 <a class="header-anchor" href="#_0-概述" aria-label="Permalink to &quot;0 概述&quot;">​</a></h2><p>密码通常作为一个行为的凭证，例如登录，但DNA也被称为遗传密码，密码实际是将一种信息转换为另一种信息并记录下来。将音频或视频存储为数据是一种编码，密码也可以理解为一种神秘的编码。密码是一个庞大复杂的信息处理体系，设计<strong>机密、完整、认证</strong>等很多功能。密码就是让窃听者无法窃取的信息，单向散列函数可以验证信息是否被篡改，数字签名可以确定消息是否来自合法的发送者。</p><h2 id="_1-环游密码世界" tabindex="-1">1 环游密码世界 <a class="header-anchor" href="#_1-环游密码世界" aria-label="Permalink to &quot;1 环游密码世界&quot;">​</a></h2><h3 id="_1-1-密码的含义" tabindex="-1">1.1 密码的含义 <a class="header-anchor" href="#_1-1-密码的含义" aria-label="Permalink to &quot;1.1 密码的含义&quot;">​</a></h3><p>发送者A向接受者B发送信息的过程就有可能被窃听者C获取，C可能并不是人类，可能是一段脚本或其他植入的窃听器。如果A不想让别人看到自己发送的消息内容，就要对内容进行加密后发出去，加密之前的内容称为明文，加密之后的内容称为密文。B收到A的消息后，仍然无法读取密文，于是B要对消息密文进行解密，也就是将密文恢复为明文状态。窃听者在获取到密文消息后无法读取，而接受者可以在获取到密文消息后进行解密后读取。这样就保证了消息内容的机密性。</p><p>破译原称为密码破译或者密码分析，破译也就是将密文进行解密的过程。破译发生在接受者正确得到密文消息之后，或者窃听者窃取到密文消息之后，或者科研人员在对密文进行强度测试时发生。</p><h3 id="_1-2-对称密码与公钥密码" tabindex="-1">1.2 对称密码与公钥密码 <a class="header-anchor" href="#_1-2-对称密码与公钥密码" aria-label="Permalink to &quot;1.2 对称密码与公钥密码&quot;">​</a></h3><p>解决复杂问题的步骤可以称之为算法，明文加密的过程也就是通过算法将明文进行计算的过程，这被称为加密算法，而解密或者称作破译的过程也就是解密算法。加密和解密的算法共同称为密码算法。密码算法中的秘钥类似钥匙：形状微妙而复杂。密码算法中的秘钥通常为一串很长的无规律字符或数字。在进行加密或进行解密时，都需要秘钥的参与。</p><p>对称密码表示在加密和解密时使用的同一秘钥，也称为公共秘钥密码、传统密码、私钥密码、共享秘钥密码。公钥密码指在加密和解密时采用不同的秘钥，也称为非对称密码。</p><p>将对称密码和公钥密码结合起来的密码称为混合密码系统，这种系统结合了两者共同的优势。</p><h3 id="_1-3-其他密码技术" tabindex="-1">1.3 其他密码技术 <a class="header-anchor" href="#_1-3-其他密码技术" aria-label="Permalink to &quot;1.3 其他密码技术&quot;">​</a></h3><p>**攻击类型可分为：**窃听（秘密泄露）、篡改（信息被修改）、伪装（伪装成发送者）、否认（事后称没有做）</p><p>**攻击的应对方案为：**机密性（窃听）、完整性（篡改）、认证（伪装）、不可否认性（否认）</p><p>**对应的密码技术：**对称密码（机密性）、公钥密码（机密性）、单向散列函数（完整性）、消息认证码（完整性+认证）、数字签名（完整性+认证+不可否认性）</p><h4 id="_1-3-1-单向散列函数" tabindex="-1">1.3.1 单向散列函数 <a class="header-anchor" href="#_1-3-1-单向散列函数" aria-label="Permalink to &quot;1.3.1 单向散列函数&quot;">​</a></h4><p>例如消息发送后，接受者对消息完整性进行验证。发送消息时公布此消息的散列值，也称为哈希值，或者指纹、信息摘要、密码校验，这个值就是通过单向散列函数进行运算得出。接收到消息后可以同样使用单向散列函数对接收到的消息获取散列值，验证接收到的散列值与发送来的散列值是否一致，从而验证信息是否被篡改或不完整。</p><h4 id="_1-3-2-消息认证码" tabindex="-1">1.3.2 消息认证码 <a class="header-anchor" href="#_1-3-2-消息认证码" aria-label="Permalink to &quot;1.3.2 消息认证码&quot;">​</a></h4><p>例如想要获得指定发送者发送的消息，则可以使用消息认证码来确定内容是否被篡改，并确定消息发送方是谁，在保证完整性的基础上实现了认证机制。</p><h4 id="_1-3-3-数字签名" tabindex="-1">1.3.3 数字签名 <a class="header-anchor" href="#_1-3-3-数字签名" aria-label="Permalink to &quot;1.3.3 数字签名&quot;">​</a></h4><p>如果发送方的信息被盗用，窃听者通过伪装的方式模仿发送方发送消息给接收方，接收方在做单向散列函数验证时通过，但实际数据并未发送方发送，而是被窃听者伪装的。数字签名可以将类似现实世界的签名或盖章的数据携带到消息中一起发送。接收方在进行单向散列函数验证之后再次验证数字签名，就可以避免伪装和篡改的问题，并且这样能防止事后发送方否定先前操作。数字签名是保证数据完整性、提供认证并防止否认的密码技术。</p><h4 id="_1-3-4-伪随机数生成器" tabindex="-1">1.3.4 伪随机数生成器 <a class="header-anchor" href="#_1-3-4-伪随机数生成器" aria-label="Permalink to &quot;1.3.4 伪随机数生成器&quot;">​</a></h4><p>可以模拟产生随机数列的算法，担任着秘钥生成的职责，在web应用通讯时，每个会话都会被分配一个秘钥，这个秘钥就是伪随机数生成器制造的，如果生成的秘钥算法不好就会被窃听者窃取。</p><h3 id="_1-4-隐写术与数字水印" tabindex="-1">1.4 隐写术与数字水印 <a class="header-anchor" href="#_1-4-隐写术与数字水印" aria-label="Permalink to &quot;1.4 隐写术与数字水印&quot;">​</a></h3><p>密码是一种让内容无法解读的技术，除此还存在隐写术。让消息内容仍然可读取，但能够隐藏真正的数据信息，这类似藏头诗。隐写术的目的就是隐藏消息本身，只有搞清楚嵌入消息的方法，就能获得正确的消息内容。数字水印是一种将著作权及购买者信息嵌入文件的技术，就会采用隐写术的方法。但单纯采用隐写术并不能使数据保密，通常还会与其他加密技术结合。密码隐藏内容，隐写术隐藏正确的内容信息，两者结合能够更安全的保护数据。</p><h3 id="_1-5-密码与信息安全常识" tabindex="-1">1.5 密码与信息安全常识 <a class="header-anchor" href="#_1-5-密码与信息安全常识" aria-label="Permalink to &quot;1.5 密码与信息安全常识&quot;">​</a></h3><h4 id="_1-5-1-不要使用保密的密码算法" tabindex="-1">1.5.1 不要使用保密的密码算法 <a class="header-anchor" href="#_1-5-1-不要使用保密的密码算法" aria-label="Permalink to &quot;1.5.1 不要使用保密的密码算法&quot;">​</a></h4><p>如果自己生产了一套加密算法，并不像外界公开会自认为更安全，但应该使用那些公开的、被公认为强度较高的密码算法。因为密码算法的秘密早晚会公开，开发高强度的密码算法也非常困难，普通的开发人员都能开发自己的密码算法，这样的密码看起来很牢靠，但对于破译人员来说却非常简单，一些公认的高强度密码算法在很长一段时间里都没有被攻破，比自己新开发一套要牢靠得多。</p><p>将密码算法进行保密来保证安全性的行为被称为隐蔽式安全性，是非常危险的。只要将足够量的明文和密文提供给破译人员，在不控制时间的情况下都能被破解。</p><h4 id="_1-5-2-使用低强度的密码比不进行任何加密更危险" tabindex="-1">1.5.2 使用低强度的密码比不进行任何加密更危险 <a class="header-anchor" href="#_1-5-2-使用低强度的密码比不进行任何加密更危险" aria-label="Permalink to &quot;1.5.2 使用低强度的密码比不进行任何加密更危险&quot;">​</a></h4><p>密码一词会给人错误的安全感，明文密码的复杂性比加密算法的强度更重要。</p><h4 id="_1-5-3-密码知识信息安全的一部分" tabindex="-1">1.5.3 密码知识信息安全的一部分 <a class="header-anchor" href="#_1-5-3-密码知识信息安全的一部分" aria-label="Permalink to &quot;1.5.3 密码知识信息安全的一部分&quot;">​</a></h4><p>攻击分为多种，信息安全终归是围绕人文来进行研究，例如电信诈骗等社会工程学攻击，并没有对用户密码进行窃取，而是采用直接攻击用户明文的方式。</p><h2 id="_2-历史上的密码" tabindex="-1">2 历史上的密码 <a class="header-anchor" href="#_2-历史上的密码" aria-label="Permalink to &quot;2 历史上的密码&quot;">​</a></h2><h3 id="_2-1-凯撒密码" tabindex="-1">2.1 凯撒密码 <a class="header-anchor" href="#_2-1-凯撒密码" aria-label="Permalink to &quot;2.1 凯撒密码&quot;">​</a></h3><p>将明文所使用的的字母表按照一定字数平移进行加密，例如下对字母表进行三个字母的平移：</p><p><img src="'+o+'" alt="微信截图_20210805144708"></p><p>其中，移动几个字母就是秘钥，需要发送者和接受者都了解。当然在了解到凯撒密码的加密方式之后，还可以对其进行暴力破解，也就是从0开始尝试移动字符尝试获取到有意义的单词，从而完成破解。</p><h3 id="_2-2-简单替换密码" tabindex="-1">2.2 简单替换密码 <a class="header-anchor" href="#_2-2-简单替换密码" aria-label="Permalink to &quot;2.2 简单替换密码&quot;">​</a></h3><p>凯撒密码通过规律的运动实现明文与密文的对应关系，如果明文字母与密文字母之间采用某种随机的对应关系就成为简单替换密码：</p><p><img src="'+p+'" alt="image-20210805145620892"></p><p>进行加密解密时，只要参考对应表就可以完成对明文的加密。其中明文密文对应表的每一个对应关系都是秘钥，需要发送方和接收方都了解。</p><h3 id="_2-3-秘钥空间" tabindex="-1">2.3 秘钥空间 <a class="header-anchor" href="#_2-3-秘钥空间" aria-label="Permalink to &quot;2.3 秘钥空间&quot;">​</a></h3><p>凯撒密码和简单替换密码实际上都是可以破译的，但是凯撒密码相对简单，耗费的时间较短，因为秘钥只有一个数字，而简单替换密码的秘钥个数较多，不容易破解。一种密码能够使用的所有秘钥的集合被称为此算法的秘钥空间。密钥空间越大，暴力破解难度越难。</p><h3 id="_2-4-用频率分析来破解密码" tabindex="-1">2.4 用频率分析来破解密码 <a class="header-anchor" href="#_2-4-用频率分析来破解密码" aria-label="Permalink to &quot;2.4 用频率分析来破解密码&quot;">​</a></h3><p>除了采用暴力破解的方式，还可以采用频率分析的密码破译方式来破译简单替换密码。例如在获取到一大段密文信息之后，在已知传输的数据为英文的情况下对密文的单个字母进行个数统计，再获取到普通的一段代表性明文，这段明文可能与已知的密文并没有关系，然后通过字母数量的对照进行推算得出每个秘钥的信息。</p><p>高频字母和低频字母都能成为破解的线索，搞清开头和结尾以及单词之间的分隔符也是线索，并且在密文越长的情况下更容易完成破译，连续出现的密文字母也能成为破解的线索。</p><h3 id="_2-5-enigma密码机" tabindex="-1">2.5 Enigma密码机 <a class="header-anchor" href="#_2-5-enigma密码机" aria-label="Permalink to &quot;2.5 Enigma密码机&quot;">​</a></h3><p>Enigma是一种能够进行加密和解密的机器，采用机械和电路实现并应用于军事。</p><p>密码机的功能与加密算法相同，密码机所生成的秘钥被记录在国防密码本上，其中记载了发送者和接受者所采用的的每日密码，通过密码本对照对密文进行破解。</p><h4 id="_2-5-1-加密原理" tabindex="-1">2.5.1 加密原理 <a class="header-anchor" href="#_2-5-1-加密原理" aria-label="Permalink to &quot;2.5.1 加密原理&quot;">​</a></h4><p>当按下ABCD中的任何一个键，都会通过各机械及电路设备的加密来电量ABCD中的一个灯泡，如图展示按下A后点亮灯泡D：</p><p><img src="'+s+'" alt="image-20210805152243259"></p><p>接线板是一个每天都会改变但当日不会改变的可插拔件，接线板的电路连接由国防军密码本的每日密码来决定。转子是圆盘装置，两点接触则触发电线相连，此盘会在每次点击按钮后自动旋转，以保证同一字母不会出现同样的密文，转子将在每次使用前旋转到默认值。</p><p>首先操作者通过密码本的参考设置正确的接线板，并归零三个转子。接下来发送者随机想出三个字母，这三个字母被称为通讯密码。通过密码机加密，这三个随机字母要输入两次在密码机中，每次的输入都将让转子转动，并让灯泡亮起，并记录对应的密文。每个转子上都标志着字母，通讯密码的明文的三个字母标识着三个转子的初始位置。接着操作者将转子转到通讯密码明文所标志的位置对消息信息进行加密并获得密文，通讯密码的密文拼接上消息密码的密文在一起通过电报发出去即实现了一次消息的加密。</p><p>已知转子的个数为3，那通讯密码的明文也肯定为3，因为通讯密码输入了两次，所以在消息之前拼接的前6个字符就是通讯密码的密文。接收方的密码机和发送方的一样，并且采用同一密码本，那要首先将接线板接好后将转盘归零，输入接收消息的前三个密文从而获得通讯密码，然后将转盘调整到通讯密码的位置后破译剩下的消息内容即可。</p><h4 id="_2-5-2-每日密码与通讯密码" tabindex="-1">2.5.2 每日密码与通讯密码 <a class="header-anchor" href="#_2-5-2-每日密码与通讯密码" aria-label="Permalink to &quot;2.5.2 每日密码与通讯密码&quot;">​</a></h4><p>每日密码是用来加密通讯密码的，当然在后续操作中也加密了消息内容，通讯密码是用来加密消息内容的。也就是说每日密码和通讯密码都属于秘钥，每日密码这种加密秘钥的秘钥在当今还在沿用。采用双重加密的方式可以避免同一个秘钥加密的密文越多，破译的线索也会变多的问题。</p><h4 id="_2-5-3-避免通信错误" tabindex="-1">2.5.3 避免通信错误 <a class="header-anchor" href="#_2-5-3-避免通信错误" aria-label="Permalink to &quot;2.5.3 避免通信错误&quot;">​</a></h4><p>通信密码输入了两次是为了解决当时无线电质量差导致消息丢失的问题，接受者对内容进行破解的时候也是重复两次进行破解，如果破解到的内容不是三个字母重复两次，就会认定此报文无效，也无法完成破解。</p><h4 id="_2-5-4-弱点" tabindex="-1">2.5.4 弱点 <a class="header-anchor" href="#_2-5-4-弱点" aria-label="Permalink to &quot;2.5.4 弱点&quot;">​</a></h4><p>转子一在旋转一周之后才会使转子二旋转，那在加密通讯密码的时候就只有转子一在旋转，这使转子所产生的秘钥从三组变成了两组，从而容易破解。将通讯密码输入两次的操作如果泄露给破解者，那也会着重破解前六个字母的信息。通讯密码是操作者自己选定的，如果采用了较为简单的通讯密码也将导致消息容易被破解。</p><p>并且国防密码本的泄露也出现了秘钥配送问题，如果泄露则要重新颁布国防密码本。</p><h4 id="_2-5-5-密码机的破解" tabindex="-1">2.5.5 密码机的破解 <a class="header-anchor" href="#_2-5-5-密码机的破解" aria-label="Permalink to &quot;2.5.5 密码机的破解&quot;">​</a></h4><p>因为密码机不依赖隐蔽式安全性，所以间谍很容易了解到密码机的原理，但因为每日密码是机密的，所以仍然无法破解密码机所生产出来的密文。由于每日密码在当天不会发生改变，所以破译人员针对当日的前六个字母也就是通讯密码进行研究，最终图灵制造了一套破解机，从而破译了Enigma的密文和加密算法。</p><h3 id="_2-6-秘钥与算法" tabindex="-1">2.6 秘钥与算法 <a class="header-anchor" href="#_2-6-秘钥与算法" aria-label="Permalink to &quot;2.6 秘钥与算法&quot;">​</a></h3><p>所有的成熟的加密都存在秘钥和算法，并且两者都是分开的。算法在运算一个字母后肯定得到另一个字母，但秘钥的加入使算法并不再那么肯定的生成一个字母了，这相当于每次加密时都产生了新的加密算法，因为由于秘钥的干扰导致算法的结构不再那么一定。算法的开发总想能够对一套算法进行重复使用，但重复使用就会增加破解的风险，秘钥的加入能够解决这个问题。</p><h2 id="_3-对称密码" tabindex="-1">3 对称密码 <a class="header-anchor" href="#_3-对称密码" aria-label="Permalink to &quot;3 对称密码&quot;">​</a></h2><h3 id="_3-1-编码" tabindex="-1">3.1 编码 <a class="header-anchor" href="#_3-1-编码" aria-label="Permalink to &quot;3.1 编码&quot;">​</a></h3><p>计算机操作对象都是比特序列，也就是二进制，无论是任何数据进入计算机都是如此，这一过程被称为编码。虽然生成的二进制人类不可读，但也不称为密码，因为这些字符会被计算机快速识别读取。</p><h3 id="_3-2-xor算法" tabindex="-1">3.2 XOR算法 <a class="header-anchor" href="#_3-2-xor算法" aria-label="Permalink to &quot;3.2 XOR算法&quot;">​</a></h3><p>XOR就是位运算中的异或运算，两个比特值相同则为0，不同则为1。A值与B值进行异或运算后，得到的结果与A进行异或运算则会得到B，反之亦然，这很类似加密与解密的过程，A作为消息内容，B作为秘钥，异或运算的结果作为密文。</p><p>采用此异或运算，可以对点阵图像进行加密及还原：</p><p><img src="'+h+'" alt="image-20210805161141288"></p><p>其中蒙版作为秘钥的角色，图像作为明文，被掩盖的图像作为密文。</p><h3 id="_3-5-一次性密码本" tabindex="-1">3.5 一次性密码本 <a class="header-anchor" href="#_3-5-一次性密码本" aria-label="Permalink to &quot;3.5 一次性密码本&quot;">​</a></h3><p>一次性密码本称为绝对不会被破译的密码，只要通过暴力破解对秘钥空间进行遍历，无论什么密文总会被破解，但一次性密码本即使使用暴力破解的方法也无法破解。其原理是将明文的每一个字母与一串随机比特序列进行XOR运算后得到的密文，这串字符可以是任意字符甚至是一本名著，破解时只需要将所有密文字母再与加密时相同的比特序列进行运算即可还原。因为字母与比特序列运算后得到的比特序列存储在计算机，计算机识别这些序列时并不会正常回显为正常的字符，从而实现了加密。</p><p>一次性密码本的方式在发送完消息后会将秘钥立马销毁，以避免重复的使用。它并未在现实世界的时间内难以破解，而是指即使拥有运算能力很强的计算机，可以在一瞬间遍历任意大小的秘钥空间也无法破解。假设对此类密码进行暴力破解，当然在某一次尝试时总能获得正确的明文，但问题是无法判断此信息是否是正确的明文。进行破解的过程中，比特数值的不断尝试会让结果出现各种各样的字符，这些字符可能存在意义或者不存在意义，但总能出现有意义的一段话，在其中出现的内容无法确定哪个是真正有意义的明文。</p><p>但是这种方式并没有被采用，首先因为秘钥的配送问题：一次性密码本的方式限制明文与秘钥的长度等长或秘钥更长一些，例如A通过此加密方式发送了密文给B，后传输了秘钥给B，但如果能够将秘钥安全的送出，应该也能同样的将明文送出，这就失去了A去做加密操作的意义。同样的道理，秘钥的长度与明文相同，秘钥既然能够秘密的保存下来，那明文也应该能妥善的保密保存。也就是说，在一次性密码本的使用过程中，将常规密码使用过程中考虑的“安全的传送和保存明文”的操作解决了，但接下来就是“安全的传送和保存秘钥”的问题，那如果继续采用一次性密码本的方式处理秘钥，接着还是会出现相同问题，但如果采用其他的安全的加密方式，为什么不直接采用这种加密方式来加密明文呢。</p><p>一次性密码本的秘钥都是一次性的，也就是说所有的秘钥都不存在重用情况。秘钥在进行解密时，肯定是一个与正文同样大小的文件，只要有一点差错就无法解析出正确的内容，当文档过长也将导致此问题。并且秘钥的生成也是一个无法重现的复杂算法。</p><p>现一次性密码本仅用于基本重于一切，不惜成本且可安全配送秘钥的场合。根据一次性密码本的理论出现了流密码模式，但其秘钥的生成是借助伪随机数生成器产生的，这也就降低了密钥生成的难度。如果要解决秘钥长度的问题可能会想到压缩的方式，但压缩是对数据中的冗余重复序列替换为较短的序列，然而一次性密码本的密钥匙随机的，并不存在重复的冗余数据，或者说如果一个秘钥可以被压缩，那就不是一个随机的比特序列。</p><h3 id="_3-6-des加密算法" tabindex="-1">3.6 DES加密算法 <a class="header-anchor" href="#_3-6-des加密算法" aria-label="Permalink to &quot;3.6 DES加密算法&quot;">​</a></h3><p>DES是一种将64比特的明文转换成64比特的密文的对称加密算法，秘钥长度为56比特，秘钥中每隔7比特就有一个用于检查错误的比特，所以只存在56比特秘钥。DES每次只能对64比特进行加密，如果内容过长则要迭代加密，其具体方式被称为模式。</p><p>DES的基本结构成为Feistel网络、Feistel结构、Feistel密码，应用于许多密码算法中。在Feistel网络中，加密的每个步骤被称为轮，整个内容的加密过程会被分为若干轮进行：</p><p><img src="'+l+'" alt="image-20210805172109798"></p><p>将64比特明文内容分为左右两半部分，输出的密文结果也是左右两半的，子秘钥用于对一次64比特明文加密所有，每一轮都会用到新的秘钥，因为每一轮的秘钥在整个内容中只占一部分数据的加密工作，所以称为子秘钥。轮函数会将右侧数据内容以及子秘钥进行结合对左侧内容进行加密，函数输出的左侧的数据与左侧原数据进行XOR运算最终得到左侧的密文，而右侧的明文将直接作为密文的一部分使用。</p><p>因为右侧的明文并未被加密，所以要将加密之后的64比特密文左右对调后，采用不同的子秘钥再次进行加密。注册操作将执行若干次，最后一轮加密后对调的操作就结束了，每一个64比特数据都将经历以下：</p><p><img src="'+n+'" alt="image-20210805172818490"></p><p>进行解密时只需要采用同样的加密算法和子秘钥将密文输入到轮体系中，就可以获取到明文，无论轮的次数有多少，也就表示Feistel的加密和解密的算法是相同的。</p><p>Feistel网络的轮数可以任意增加，并且不会出现无法解密的情况，并且无论采用何种轮函数，都可以进行正确的解密，这个体系抽取出密码的本质部分并封装成一个轮函数，设计密码算法的人只需将加密设计的无限复杂就可以，无需考虑解密的算法，因为加密和解密可以采用相同的结构来实现。</p><p>每一轮中的右侧并未加密，虽然有点浪费但保证了可解密性。由于Feistel的便捷，被许多分组密码算法所借鉴。例如MARS、RC6、Twofish都是才用的此种结构。</p><h3 id="_3-7-差分分析与线性分析" tabindex="-1">3.7 差分分析与线性分析 <a class="header-anchor" href="#_3-7-差分分析与线性分析" aria-label="Permalink to &quot;3.7 差分分析与线性分析&quot;">​</a></h3><p>差分分析是针对分组密码的分析方式，改变一部分明文并分析密文符合随着改变。理论上说，即使改变明文的一个比特符号，也将导致密文的更改，从而破解密码。</p><p>线性分析是将明文和密文的一些对应比特进行XOR进行计算其结果为零的概率，如果密文足够随机，任选一些明文和密文的对应比特进行XOR结果为零的概率应为二分之一，只要找到偏离二分之一的部分就可以获得破解的线索。</p><p>差分分析和线性分析都有一个前提，就是获得明文和密文，这种攻击方式称为选择明文攻击。以AES为代表的现代分组密码算法，在设计上已经针对这两种破解方式进行设计。</p><h3 id="_3-8-三重des" tabindex="-1">3.8 三重DES <a class="header-anchor" href="#_3-8-三重des" aria-label="Permalink to &quot;3.8 三重DES&quot;">​</a></h3><p>因为DES现已经可以在一定时间内暴力破解，所以出现了替代DES的分组密码三种DES。也就是为增强DES的强度将DES操作重复三次，也称为3DES。</p><p><img src="'+d+'" alt="image-20210806135306874"></p><p>明文经历三次DES产生密文，由于DES秘钥实际长度为56比特，实际三种DES的秘钥程度就是168比特。因为DES在经历加密后再次通过密文进入DES系统应该就会明文，也就是说第一次DES后产生的密文将在第二次DES解密后产生明文后在进行加密，目的是让3DES能够兼容普通DES。3DES的三个秘钥都是不同的，如果相同那第二次DES实际得到的还是明文，得到的结果实际和普通DES相同，这样只要把三个秘钥设置成同样的，那就可以兼容DES的解密方式。</p><p>如果3DES中的第一个秘钥和第三个秘钥相同，这种方式称为DES-EDE2，EDE表示加密到解密到加密的流程，如果三个秘钥都不相同则称为DES-EDE3。下面展示DES-EDE2：</p><p><img src="'+_+'" alt="image-20210806135908287"></p><p>三种DES的解密就是反向的采用三个秘钥但同样采用DES流程从而得到明文：</p><p><img src="'+c+'" alt="image-20210806140028854"></p><h3 id="_3-9-aes选定流程" tabindex="-1">3.9 AES选定流程 <a class="header-anchor" href="#_3-9-aes选定流程" aria-label="Permalink to &quot;3.9 AES选定流程&quot;">​</a></h3><p>AES是取代DES成为新标准的一种对称密码算法标准，全世界很多种密码算法都可以作为AES的候选，AES参选的密码都必须向公众开源并提供详细规格书，这种通过竞争来实现标准化的方式是正确的，密码由公众提供且由公众破译并未发现弱点才能证明算法的强度。</p><h3 id="_3-10-rijndael" tabindex="-1">3.10 Rijndael <a class="header-anchor" href="#_3-10-rijndael" aria-label="Permalink to &quot;3.10 Rijndael&quot;">​</a></h3><p>Rijndael是一种分组密码算法，于2000年选为AES标准算法，它的分组长度和秘钥长度分别以32比特为单位，在128比特到256比特之间进行选择，但在AES标准中，分组长度固定为128比特，秘钥长度只有128、192、256三种规格。</p><p>Rijndael算法也分为轮，每轮存在SubBytes，ShiftRows，MixColumns，AddRoundKey四个步骤，并未想DES一样采用Feistel网络，而是采用SPN结构。Rijndael输入分组为128比特（16字节），将逐个字节进行SubBytes处理，以每个字节的值（0-255）为索引，从一张拥有256个值的替换表中找到对应的值，对每一个字节进行替换：</p><p><img src="'+m+'" alt="image-20210806141113335"></p><p>接下来就是ShiftRows，以四字节为单位的行按照一定规则向左平移，并且每行平移的字节是不同的：</p><p><img src="'+u+'" alt="image-20210806141218613"></p><p>接下来是MaxColumns处理，对一个4字节的值进行比特运算，将其编程另外的4字节值：</p><p><img src="'+b+'" alt="image-20210806141314027"></p><p>最后将MaxColumns输出值与轮秘钥进行XOR运算，也就是AddRoundKey操作：</p><p><img src="'+q+'" alt="image-20210806141358316"></p><p>这样的操作将经历很多轮来进行，和每一轮只加密一半的Feistel相比这种方式可以采用更少的轮数完成加密，并且每一步都以字节、行、列为单位进行运算，混淆度也有所提高。</p><p>解密的过程实际就是将加密的过程反向执行即可：</p><p><img src="'+E+'" alt="image-20210806141545549"></p><h3 id="_3-11-总结" tabindex="-1">3.11 总结 <a class="header-anchor" href="#_3-11-总结" aria-label="Permalink to &quot;3.11 总结&quot;">​</a></h3><p>DES不再用于任何新用途，并且已经能够暴力进行破解。3DES也已经被AES替代，所以最应该选择的是AES，也就是Rijndael算法，更安全和快速。总之不要采用自己发明的加密算法，而是采用AES候选或已经标准化的AES算法。</p><h2 id="_4-分组密码的模式" tabindex="-1">4 分组密码的模式 <a class="header-anchor" href="#_4-分组密码的模式" aria-label="Permalink to &quot;4 分组密码的模式&quot;">​</a></h2>',122)]))}const B=e(g,[["render",S]]);export{R as __pageData,B as default};
