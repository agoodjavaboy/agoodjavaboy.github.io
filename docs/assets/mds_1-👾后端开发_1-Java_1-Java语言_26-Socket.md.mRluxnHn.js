import{_ as e,c as d,o as s,aF as i}from"./chunks/framework.CvyoTX4A.js";const k=JSON.parse('{"title":"概述与API","description":"","frontmatter":{},"headers":[],"relativePath":"mds/1-👾后端开发/1-Java/1-Java语言/26-Socket.md","filePath":"mds/1-👾后端开发/1-Java/1-Java语言/26-Socket.md"}'),a={name:"mds/1-👾后端开发/1-Java/1-Java语言/26-Socket.md"};function o(r,t,c,n,l,h){return s(),d("div",null,t[0]||(t[0]=[i(`<h1 id="概述与api" tabindex="-1">概述与API <a class="header-anchor" href="#概述与api" aria-label="Permalink to &quot;概述与API&quot;">​</a></h1><ul><li>Socket一称为套接字，为Java中抽象概念，其内部采用TCP/IP协议，将数据在多个计算机之间传输。</li><li>采用Socket编程本质为两个进程之间通讯，其中一个作为服务端监听某端口，另一进程作为客户端主动访问某IP与端口。连接成功后双方即可实现数据发送与接收。</li><li>借助Java的Socket技术，可以访问网络HTTP与FTP服务，并可获得网络资源，并可发送GET和POST方式的请求。</li><li>Socket可建立TCP服务端，并监听某端口接收请求并处理响应，亦可建立客户端发送请求至服务端接收其响应内容。其数据传输本质以IO的形式进行传输。</li></ul><h2 id="inetaddress-ip地址" tabindex="-1">InetAddress IP地址 <a class="header-anchor" href="#inetaddress-ip地址" aria-label="Permalink to &quot;InetAddress IP地址&quot;">​</a></h2><ul><li><p>InetAddress类用于描述IP地址，其子类Inet4Address与Inet6Address用于表示IPv4与IPv6地址。</p></li><li><p>其中并无构造方法，而是通过其他方法获取实例（传入IP或域名）与IP信息：</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>getByName(String host)</code></td><td>根据主机获取对应InetAddress对象。</td></tr><tr><td><code>getByAddress(byte[] addr)</code></td><td>根据原始IP地址获取对应InetAddress对象。</td></tr><tr><td><code>getCanonicalHostName()</code></td><td>获取当前IP全限定名。</td></tr><tr><td><code>getHostAddress()</code></td><td>获取IP地址。</td></tr><tr><td><code>getHostName()</code></td><td>获取IP的主机名称。</td></tr><tr><td><code>isReachable(int)</code></td><td>测试指定IP是否能够连通，防火墙与服务器配置可能导致连接失败。参数表示超时毫秒时间。</td></tr></tbody></table><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//使用getName方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InetAddress ia </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> InetAddress.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;127.0.0.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//使用getByAddress方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] host </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">127</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ia </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> InetAddress.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getByAddress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(host);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//测试连通，定超时时间两秒</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ia.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isReachable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ul><h2 id="urldecoder-urlencoder" tabindex="-1">URLDecoder URLEncoder <a class="header-anchor" href="#urldecoder-urlencoder" aria-label="Permalink to &quot;URLDecoder URLEncoder&quot;">​</a></h2><ul><li><p><code>URLDecoder URLEncoder</code>两类用于完成字符串与<code>application/x-www-form-urlencoded</code> MIME字符串之间转换。</p></li><li><p><code>application/x-www-form-urlencoded</code> MIME字符串即浏览器地址栏中所出现的类乱码的数据，当路径中出现非西欧字符时，将自动将其转换为可理解的MIME字符串，方便传输与解析。若路径中仅存在西欧字符，便无序进行转换。</p></li><li><p>两个类中各自提供静态方法用于解析MIME字符串，可直接使用类名调用，第二个参数表示编码格式：</p><table tabindex="0"><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>URLDecoder.decode(String s,String enc)</code></td><td>将MIME转换为String类型</td></tr><tr><td><code>URLEncoder.encode(String s,String enc)</code></td><td>将String类型转换为MIME类型</td></tr></tbody></table></li></ul><h2 id="url-资源定位符" tabindex="-1">URL 资源定位符 <a class="header-anchor" href="#url-资源定位符" aria-label="Permalink to &quot;URL 资源定位符&quot;">​</a></h2><ul><li><p>URL全称<code>Uniform Resource Locator</code>，代表统一资源定位符，用于在网络资源中进行定位，此资源可为文件或目录，或者更为复杂的内容。URL由协议名、主机名（IP地址）、端口与资源（访问内容）组成：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>协议名://IP地址:端口号/资源名</span></span>
<span class="line"><span>http://127.0.0.1:8080/index.html</span></span></code></pre></div><p>如果申请域名，可将IP地址与端口号改为域名。</p></li><li><p>Java提供URL类用于描述资源定位符，还有一类名为URI，表示统一资源标识符，及除IP与端口及协议名之外的内容。URI不可用于定位资源，仅可用作地址解析。</p></li><li><p>URL类中提供多个构造方法获取实例，并提供方法对资源路径进行访问：</p><table tabindex="0"><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td><code>getFile()</code></td><td>获取资源名</td></tr><tr><td><code>getHost()</code></td><td>获取主机名即IP地址</td></tr><tr><td><code>getPath()</code></td><td>获取路径部分</td></tr><tr><td><code>getPort</code></td><td>获取端口号</td></tr><tr><td><code>getProtocol()</code></td><td>获取协议名</td></tr><tr><td><code>getQuery</code></td><td>获取查询字符串部分</td></tr></tbody></table><p>并提供方法用于资源访问与传输：</p><table tabindex="0"><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td><code>URLConnection openStream()</code></td><td>返回的对象表示根据此路径与资源的连接</td></tr><tr><td><code>InputStream openStream()</code></td><td>打开连接，获得一个用于读取资源的流</td></tr></tbody></table></li></ul><h2 id="服务端" tabindex="-1">服务端 <a class="header-anchor" href="#服务端" aria-label="Permalink to &quot;服务端&quot;">​</a></h2><ul><li><p>可使用ServerSocket类创建一服务端进程，其中可用方法为：</p><table tabindex="0"><thead><tr><th>构造方法摘要</th></tr></thead><tbody><tr><td><code>ServerSocket()</code> 创建非绑定服务器套接字。</td></tr><tr><td><code>ServerSocket(int port)</code> 创建绑定到特定端口的服务器套接字。</td></tr><tr><td><code>ServerSocket(int port, int backlog) </code> 利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。</td></tr><tr><td><code>ServerSocket(int port, int backlog, InetAddress bindAddr)</code> 使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。</td></tr></tbody></table><table tabindex="0"><thead><tr><th>方法摘要</th><th></th></tr></thead><tbody><tr><td><code> Socket</code></td><td><code>accept()</code> 侦听并接受到此套接字的连接。</td></tr><tr><td><code> void</code></td><td><code>bind(SocketAddress endpoint)</code> 将 ServerSocket 绑定到特定地址（IP 地址和端口号）。</td></tr><tr><td><code> void</code></td><td><code>bind(SocketAddress endpoint, int backlog)</code> 将 <code>ServerSocket</code> 绑定到特定地址（IP 地址和端口号）。</td></tr><tr><td><code> void</code></td><td><code>close()</code> 关闭此套接字。</td></tr><tr><td><code> ServerSocketChannel</code></td><td><code>getChannel()</code> 返回与此套接字关联的唯一 ServerSocketChannel 对象（如果有）。</td></tr><tr><td><code> InetAddress</code></td><td><code>getInetAddress()</code> 返回此服务器套接字的本地地址。</td></tr><tr><td><code> int</code></td><td><code>getLocalPort()</code> 返回此套接字在其上侦听的端口。</td></tr><tr><td><code> SocketAddress</code></td><td><code>getLocalSocketAddress()</code> 返回此套接字绑定的端点的地址，如果尚未绑定则返回 <code>null</code>。</td></tr><tr><td><code> int</code></td><td><code>getReceiveBufferSize()</code> 获取此 <code>ServerSocket</code> 的 SO_RCVBUF 选项的值，该值是将用于从此 <code>ServerSocket</code> 接受的套接字的建议缓冲区大小。</td></tr><tr><td><code> boolean</code></td><td><code>getReuseAddress()</code> 测试是否启用 SO_REUSEADDR。</td></tr><tr><td><code> int</code></td><td><code>getSoTimeout()</code> 获取 SO_TIMEOUT 的设置。</td></tr><tr><td><code>protected void</code></td><td><code>implAccept(Socket s)</code> ServerSocket 的子类使用此方法重写 <code>accept()</code> 以返回它们自己的套接字子类。</td></tr><tr><td><code> boolean</code></td><td><code>isBound()</code> 返回 ServerSocket 的绑定状态。</td></tr><tr><td><code> boolean</code></td><td><code>isClosed() </code> 返回 ServerSocket 的关闭状态。</td></tr><tr><td><code> void</code></td><td><code>setPerformancePreferences(int connectionTime, int latency, int bandwidth)</code> 设置此 ServerSocket 的性能首选项。</td></tr><tr><td><code> void</code></td><td><code>setReceiveBufferSize(int size)</code> 为从此 <code>ServerSocket</code> 接受的套接字的 SO_RCVBUF 选项设置默认建议值。</td></tr><tr><td><code> void</code></td><td><code>setReuseAddress(boolean on) </code> 启用/禁用 SO_REUSEADDR 套接字选项。</td></tr><tr><td>static void</td><td><code>setSocketFactory(SocketImplFactory fac)</code> 为应用程序设置服务器套接字实现工厂。</td></tr><tr><td><code> void</code></td><td><code>setSoTimeout(int timeout)</code> 通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。</td></tr><tr><td><code> String</code></td><td><code>toString() </code> 作为 String 返回此套接字的实现地址和实现端口。</td></tr></tbody></table></li><li><p>可创建此类对象并使用有参构造方法创建服务端，并监听某端口。如果没有指定端口直接书写端口将在本计算机所有网络接口中进行监听：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ServerSocket ss </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ServerSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6666</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><p>使用循环不断监听此端口，可使用<code>accept()</code>方法，此方法将获取一Socket对象，若无数据传来，则此方法一直处于阻塞状态。</p></li></ul>`,10)]))}const E=e(a,[["render",o]]);export{k as __pageData,E as default};
