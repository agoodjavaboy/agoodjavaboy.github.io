import{_ as t,C as e,c as h,o as p,aF as a,j as i,a as l,G as k,w as r}from"./chunks/framework.CvyoTX4A.js";const d="/assets/1568103125096.mcYhjK7V.png",o="/assets/1568103071492.BqT2pQqa.png",g="/assets/image-20250317232928761.BCi4pNGZ.png",F=JSON.parse('{"title":"分页","description":"","frontmatter":{},"headers":[],"relativePath":"mds/3-🪂开发软件/1-数据库/2-Oracle/15-分页.md","filePath":"mds/3-🪂开发软件/1-数据库/2-Oracle/15-分页.md"}'),c={name:"mds/3-🪂开发软件/1-数据库/2-Oracle/15-分页.md"};function m(E,s,u,y,A,_){const n=e("font");return p(),h("div",null,[s[4]||(s[4]=a('<h1 id="分页" tabindex="-1">分页 <a class="header-anchor" href="#分页" aria-label="Permalink to &quot;分页&quot;">​</a></h1><h2 id="oracle" tabindex="-1">Oracle <a class="header-anchor" href="#oracle" aria-label="Permalink to &quot;Oracle&quot;">​</a></h2><ul><li>如果一次性将所有的记录显示出来,是非常慢的,因为数据量可能会很大.</li><li>所以将大量的数据,切割成等量的页,每次展示一页的数据.</li><li><strong>每页的数量是一定的,并且每页的数据都不可重复.</strong></li></ul><h3 id="借助伪列-sql嵌套分页" tabindex="-1">借助伪列+SQL嵌套分页 <a class="header-anchor" href="#借助伪列-sql嵌套分页" aria-label="Permalink to &quot;借助伪列+SQL嵌套分页&quot;">​</a></h3>',4)),i("ul",null,[s[1]||(s[1]=i("li",null,[i("p",null,[l("在select后面添加"),i("code",null,"rownum"),l(",显示伪列.可以展示一个在表中没有的列.")])],-1)),s[2]||(s[2]=i("li",null,[i("p",null,"伪列用来排序,默认是数字升序排列.")],-1)),i("li",null,[k(n,{color:"red"},{default:r(()=>s[0]||(s[0]=[l("rownum只能做小于和等于和小于等于运算,不能做大于运算!")])),_:1})]),s[3]||(s[3]=a(`<li><p>可以使用SQL嵌套来实现分页:</p><ul><li>内层SQL的rownum可以做小于操作,不能做大于操作,以为rownum不能做大于操作.</li><li>即使在内层select后对rownum做了别名操作,也不能在where中进行大于操作,因为where已死.</li><li>为了让伪列继续使用,在外层SQL中对伪列进行判断.</li><li>外层伪列同样不能直接操作rownum关键字,因为rownum在何地都不能做大于操作.</li><li>但是在内层SQL中书写了别名,rownum所在的rn列就变成了内层SQL制造出的临时表的一员,不再是伪列而是一个实际存在的列.</li><li>在外层SQL中,虽然不能操作rownum做大于操作,但是可以操作内层SQL制造的rn,因为rn不再是一个伪列,而是一个实际存在的列.</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    	在此表中,rn已经不是rownum了,已经不归Oracle管辖了,是临时表的一个字段.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		但是就算是已经是临时表的一个字段,也不能用where进行比较,因为where已经死去.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rownum rn,emp.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> employees emp </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rownum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	在这里操作的rn不是一个伪列,而是临时表中的一个实际的字段.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><img src="`+d+'" alt="1568103125096"></p></li>',1))]),s[5]||(s[5]=a(`<h3 id="借助minus分页" tabindex="-1">借助minus分页 <a class="header-anchor" href="#借助minus分页" aria-label="Permalink to &quot;借助minus分页&quot;">​</a></h3><ul><li>minus前后各有一个SQL语句,两个SQL语句查出不同量的值.</li><li>如果在第一个SQL语句中存在第二个SQL语句中的结果,将在第一个SQL语句中去除此结果.</li><li>语法:<code>(SQL语句产生临时表) minus (SQL语句产生临时表)</code></li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 实例:取出前20条记录,但是这些记录中不要包含前10条记录.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> employees </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rownum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">minus</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> employees </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rownum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><img src="`+o+`" alt="1568103071492"></p><h2 id="mysql" tabindex="-1">MySQL <a class="header-anchor" href="#mysql" aria-label="Permalink to &quot;MySQL&quot;">​</a></h2><h3 id="借助limit分页" tabindex="-1">借助limit分页 <a class="header-anchor" href="#借助limit分页" aria-label="Permalink to &quot;借助limit分页&quot;">​</a></h3><ul><li>limit需要两个值跟在后面,第一个值表示从哪一列开始,但不包括这一列.第二个参数表示显示几条记录.</li><li>语法:<code>select 列名 from 表名 limit 开始值(不包括此值),显示条目;</code></li><li>limit在select的后面执行.</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 示例:查询从第4(3+1)条记录开始,显示3条记录.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chengji </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><img src="`+g+'" alt="image-20250317232928761"></p>',9))])}const S=t(c,[["render",m]]);export{F as __pageData,S as default};
