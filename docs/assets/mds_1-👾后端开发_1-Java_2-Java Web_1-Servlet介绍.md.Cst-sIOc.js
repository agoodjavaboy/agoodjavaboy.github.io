import{_ as t,c as r,o as d,aF as l}from"./chunks/framework.CvyoTX4A.js";const o="/assets/1111222333.DPH7sSRG.png",b=JSON.parse('{"title":"Servlet","description":"","frontmatter":{},"headers":[],"relativePath":"mds/1-👾后端开发/1-Java/2-Java Web/1-Servlet介绍.md","filePath":"mds/1-👾后端开发/1-Java/2-Java Web/1-Servlet介绍.md"}'),v={name:"mds/1-👾后端开发/1-Java/2-Java Web/1-Servlet介绍.md"};function i(c,e,s,a,p,n){return d(),r("div",null,e[0]||(e[0]=[l('<h1 id="servlet" tabindex="-1">Servlet <a class="header-anchor" href="#servlet" aria-label="Permalink to &quot;Servlet&quot;">​</a></h1><h2 id="servlet接口" tabindex="-1">Servlet接口 <a class="header-anchor" href="#servlet接口" aria-label="Permalink to &quot;Servlet接口&quot;">​</a></h2><p><strong>Servlet接口的介绍：</strong></p><ul><li><p>定义所有servlet必须实现的方法。</p></li><li><p>servlet是一个运行在Web服务器中的小型Java程序。servlet通常通过超文本传输协议HTTP接收和响应来自Web客户端的请求。</p></li><li><p>要实现这个接口，可以编写扩展javax.servlet.GenericServlet的通用servlet或扩展javax.servlet.HTTP.HttpServlet的HTTP servlet。</p></li><li><p>这个接口定义了初始化servlet、服务请求和从服务器中删除servlet的方法。这些方法称为生命周期方法，按以下顺序调用：</p><ol><li><p>servlet被构造，然后用init方法初始化。</p></li><li><p>将处理客户端对服务方法的任何调用。</p></li><li><p>servlet将停止服务，然后使用destroy方法销毁，然后垃圾收集并最终确定。</p><p>除了生命周期方法之外，这个接口还提供getServletConfig方法（servlet可以使用它来获取任何启动信息）和getServletInfo方法（它允许servlet返回自己的基本信息，如作者、版本和版权）。</p></li></ol></li><li><p>servlet通常运行在多线程服务器上，因此请注意servlet必须处理并发请求，并小心同步对共享资源的访问，在多线程的情况下，Servlet是不安全的，要自己手动的控制同步操作。共享资源包括内存中的数据(如实例或类变量)和外部对象(如文件、数据库连接和网络连接)。</p></li></ul><table tabindex="0"><thead><tr><th>返回值类型</th><th>方法及介绍</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>destroy()</code><br>由servlet容器（Tomcat）调用，以指示servlet正在退出服务。</td></tr><tr><td><code>ServletConfig</code></td><td><code>getServletConfig()</code><br>返回一个ServletConfig的对象，其中包含此servlet的初始化和启动参数。</td></tr><tr><td><code>String</code></td><td><code>getServletInfo()</code><br>返回关于servlet的信息，如作者、版本和版权。</td></tr><tr><td><code>void</code></td><td><code>init(ServletConfig config)</code><br>由servlet容器调用，以指示servlet正在将servlet放入服务中。</td></tr><tr><td><code>void</code></td><td><code>service(ServletRequest req, ServletResponse res)</code><br>由servlet容器调用，以允许servlet响应和发送请求。</td></tr></tbody></table><blockquote><p>init：当Servlet类初始化的时候启动，多次的访问同一个Servlet类只会在第一次时执行（类似类加载：只执行一次，未来再使用多少次都不会执行了）。</p><p>service：真正的逻辑处理的位置，主要用来编写接收请求和响应内容的代码。每次请求都将启动service方法。</p><p>destroy：销毁的方法，很类似于finalize垃圾处理器，不定时的不可控的启动。</p></blockquote><p><strong>Servlet的运行声明周期（方法自动调用的顺序）：</strong></p><p><img src="'+o+'" alt=""></p><h2 id="继承结构及功能" tabindex="-1">继承结构及功能 <a class="header-anchor" href="#继承结构及功能" aria-label="Permalink to &quot;继承结构及功能&quot;">​</a></h2><h3 id="genericservlet" tabindex="-1">GenericServlet <a class="header-anchor" href="#genericservlet" aria-label="Permalink to &quot;GenericServlet&quot;">​</a></h3><ul><li>是Servlet接口的直接子==抽象类==，主要是做了Servlet接口其中抽象方法的基本实现。</li><li>定义一个通用的、独立于协议的servlet。要编写一个Web上使用的HTTP servlet，请扩展HttpServlet。</li><li>GenericServlet简化了servlet的编写。它提供了生命周期方法的简单版本，init和destroy以及ServletConfig接口中的方法。GenericServlet还实现了在ServletContext接口中声明的日志方法。</li><li>要编写通用servlet，只需覆盖抽象service方法。</li><li>如果使用GenericServlet创建自定义Servlet，必须要实现的是service方法，用来写逻辑处理。</li></ul><table tabindex="0"><thead><tr><th>方法的返回值类型</th><th>方法及作用</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>destroy()</code><br>由servlet容器调用，以指示servlet正在退出服务。</td></tr><tr><td><code>java.lang.String</code></td><td>getInitParameter(java.lang.String name)`<br>返回包含指定初始化参数值的“String”，如果参数不存在，则返回“null”。</td></tr><tr><td><code>java.util.Enumeration&lt;java.lang.String&gt;</code></td><td><code>getInitParameterNames()</code><br>返回servlet初始化参数的名称，作为&#39; String &#39;对象的&#39;Enumeration&#39;，如果servlet没有初始化参数，则返回一个空&#39;Enumeration&#39;。</td></tr><tr><td><code>ServletConfig</code></td><td><code>getServletConfig()</code><br>返回这个servlet的<code>ServletConfig</code>对象。</td></tr><tr><td><code>ServletContext</code></td><td><code>getServletContext()</code><br>&#39;返回对正在其中运行此servlet的&#39; ServletContext &#39;的引用。</td></tr><tr><td><code>java.lang.String</code></td><td><code>getServletInfo()</code><br>返回关于servlet的信息，如作者、版本和版权。</td></tr><tr><td><code>java.lang.String</code></td><td><code>getServletName()</code><br>返回此servlet实例的名称。</td></tr><tr><td><code>void</code></td><td><code>init()</code><br>一个方便的方法，可以被覆盖，因此不需要调用&#39;super.init(config) &#39;。</td></tr><tr><td><code>void</code></td><td><code>init(ServletConfig config)</code><br>由servlet容器调用，向servlet表明servlet正在被放置到服务中。</td></tr><tr><td><code>void</code></td><td><code>log(java.lang.String msg)</code><br>将指定的消息写入servlet日志文件，并以servlet的名称作为前缀。</td></tr><tr><td><code>void</code></td><td><code>log(java.lang.String message, java.lang.Throwable t)</code><br>向servlet日志文件中写入说明消息和给定的“可抛出”异常的堆栈跟踪，并以servlet的名称作为前缀。</td></tr><tr><td><code>abstract void</code></td><td><code>service(ServletRequest req, ServletResponse res)</code><br>由servlet容器调用，以允许servlet响应请求。</td></tr></tbody></table><h3 id="httpservlet" tabindex="-1">HTTPServlet <a class="header-anchor" href="#httpservlet" aria-label="Permalink to &quot;HTTPServlet&quot;">​</a></h3><ul><li><p>是GenericServlet的子==实现类==，间接的实现了Servlet接口，主要是优化了GenericServlet对Servlet的处理实现，更加的适合Http类型的协议。</p></li><li><p>创建适合于Web站点的HTTP servlet。</p></li><li><p>HttpServlet里面没有抽象的方法，也就是说如果我们使用HttpServlet去创建自定义Servlet类是可以不重写任何方法的。但是不会这么做，因为每一个Servlet服务都要有请求和接收的操作，这些操作起码要用service方法来处理。所以我们至少要重写其中一个执行逻辑处理的方法：doget、dopost、service。</p></li><li><p>HttpServlet中，对各种的请求方式都做了方法的声明，不同的请求方式将自动的调用对应的方法。service方法可以完成对任何请求的处理。</p><ol><li><p>GET：向特定资源发送请求，一般是用来查询数据。如果向浏览器发送数据，则会在浏览器的地址栏拼接请求的内容，是不安全的。但是只会发送一个数据包速度较快。</p></li><li><p>POST：向指定的资源，提交数据进行处理请求，有可能创建或修改已有数据。提交数据是不会在地址栏显示的，会发送两个数据包，比get方式较慢。</p></li><li><p>HEAD：和Get请求相一致，只不过不会返回响应体,这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。（用于获取报头）</p></li><li><p>OPTIONS：返回服务器对特定资源所支持的http的请求，可以用来向Web服务器发送请求来测试服务器的功能性</p></li><li><p>PUT：向指定资源位置上传最新的内容</p></li><li><p>DELETE：请求服务器删除Request-URI所标识的资源</p></li><li><p>TRACE：回显服务器收到的请求，主要用于测试或诊断</p></li><li><p>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p></li></ol></li></ul><table tabindex="0"><thead><tr><th>返回值类型</th><th>方法名及描述</th></tr></thead><tbody><tr><td><code>protected void</code></td><td><code>doDelete(HttpServletRequest req, HttpServletResponse resp)</code><br>由服务器调用(通过“service”方法)，允许servlet处理删除请求。</td></tr><tr><td><code>protected void</code></td><td><code>doGet(HttpServletRequest req, HttpServletResponse resp)</code><br>由服务器(通过“服务”方法)调用，以允许servlet处理GET请求。</td></tr><tr><td><code>protected void</code></td><td><code>doHead(HttpServletRequest req, HttpServletResponse resp)</code><br>从受保护的“服务”方法接收HTTP头请求并处理请求。</td></tr><tr><td><code>protected void</code></td><td><code>doOptions(HttpServletRequest req, HttpServletResponse resp)</code><br>由服务器(通过服务方法)调用，以允许servlet处理选项请求。</td></tr><tr><td><code>protected void</code></td><td>doPost(HttpServletRequest req, HttpServletResponse resp)`<br>由服务器(通过“服务”方法)调用，以允许servlet处理POST请求。</td></tr><tr><td><code>protected void</code></td><td><code>doPut(HttpServletRequest req, HttpServletResponse resp)</code><br>由服务器(通过“服务”方法)调用，以允许servlet处理PUT请求。</td></tr><tr><td><code>protected void</code></td><td><code>doTrace(HttpServletRequest req, HttpServletResponse resp)</code><br>由服务器(通过“服务”方法)调用，以允许servlet处理跟踪请求。</td></tr><tr><td><code>protected long</code></td><td><code>getLastModified(HttpServletRequest req)</code><br>返回“HttpServletRequest”对象最后一次修改的时间，从格林威治时间1970年1月1日午夜开始，以毫秒为单位。</td></tr><tr><td><code>protected void</code></td><td><code>service(HttpServletRequest req, HttpServletResponse resp)</code><br>接收来自公共“服务”方法的标准HTTP请求，并将它们分派给该类中定义的“do”XXX方法。</td></tr><tr><td><code>void</code></td><td><code>service(ServletRequest req, ServletResponse res)</code><br>将客户端请求分派给受保护的“服务”方法。</td></tr></tbody></table><blockquote><p>接口用于规定必须要实现的功能：收发，初始化，销毁。所有要做这件事情的子实现类都要有最基本的实现。</p><p>抽象类把能完成的事情都完成，不能完成的就抽象化，哪个子类用，就哪个子类去写实现。之所以让子类去实现，是因为不同的子类要有不同的实现方式。</p><p>比如Servlet是完成前后台交互的一个接口，那登录要收发的内容和注册要收发的内容不相同。</p></blockquote><h1 id="hello-web" tabindex="-1">Hello Web <a class="header-anchor" href="#hello-web" aria-label="Permalink to &quot;Hello Web&quot;">​</a></h1><blockquote><p>用户在浏览器上通过地址栏或者a标签或者form表单的action属性值向后台发送请求。</p><p>请求根据IP和端口号到达Tomcat服务器，服务器会解析请求的路径，找到访问的项目。</p><p>服务器会在web.xml或者注解中查找与请求相关的Servlet类（路径映射）。</p><p>然后自动的执行这个Servlet类的init方法，然后是service方法。</p></blockquote>',18)]))}const g=t(v,[["render",i]]);export{b as __pageData,g as default};
